# 유일 ID 생성기 설계
## 요구사항
- 유일하며 정렬 가능하다.
- ID가 1씩 증가하는 것은 아니지만, 시간이 지날수록 숫자의 크기는 커야 한다.
- 초당 10,000개의 ID를 생성할 수 있다.
- 64비트로 표현될 수 있어야 한다.

## 후보
### 다중 마스터 복제
- auto_increment를 사용한다. 다만 1이 아닌 N씩 증가시킨다.
- 다만, 서버의 확장이 없다.
- 유일한 값을 보장할 수 있으나, 그 값을 전체 값을 모와서 정렬할 때 시간의 순서임을 보장할 수 없다. 

### UUID
- 128비트이다.
- 시간순으로 정렬할 수 없다(버전마다 다르지만)
- 숫자가 아닌 값이 포함된다.

### 티켓서버
- 별도의 ID 생성 서버를 둔다.
- 만들기 쉽다. 다루기 쉽다.
- 다만, SPOF 문제가 발생 한다.

## 트위터 스노플레이크
- 64비트의 숫자로 이뤄진 ID 생성 로직

### 구성
- 1비트 : sign: 현재 쓰임새가 없으나 나중을 위해 유보한 값
- 41비트 : timestamp: epoch로서 사용하며 그 시간은 트위터의 설정에 따라 다르다.
- 5비트 : 데이터 센터 ID: 2^5개로 32개의 데이터 센터를 지원한다.
- 5비트 : 서버 ID: 하나의 데이터 센터에서 32개의 서버를 사용할 수 있다.
- 12비트 : 일련번호 : 각 서버에서는 ID를 생성할 때마다 이 번호를 1씩 증가시킨다. 1밀리초가 경과할 때마다 0으로 초기화 된다.

- 데이터센터 32개와 서버32개가 분산 처리를 할 경우 총 1024개의 서버가 존재한다. 그럼 하나의 서버는 평균적으로 10개의 일련번호를 생성하면 된다. 


### 다중 서버에서의 쟁점
- 시계 동기화 clock synchronization : 서버는 같은 시계를 사용해야 한다. NTP(Network Time Protocol)은 보편적인 해결 방식이다.
- 필요에 따라 각 비트의 갯수를 조절할 수 있다. 동시성이 적을 수록 타임스탬프를 늘리는 것이 유리하다.
- 고가용성 : ID 생성기는 높은 가용성을 요구 받는다.